/*
 * Copyright (C) 1996-2025 The Squid Software Foundation and contributors
 *
 * Squid software is distributed under GPLv2+ license and includes
 * contributions from numerous individuals and organizations.
 * Please see the COPYING and CONTRIBUTORS files for details.
 */

#ifndef SQUID_SRC_CONFIGURATION_SMOOTH_H
#define SQUID_SRC_CONFIGURATION_SMOOTH_H

#include "base/AsyncCallList.h"
#include "configuration/forward.h"
#include "peering.h"

namespace Configuration {

/// Facilitates collection of conditional intrusive tasks (requested by fairly
/// uncoordinated directive-specific reconfiguration code) for final
/// reconfiguration steps. Due to their high-cost intrusiveness, we do not want
/// to run these tasks once unconditionally (e.g., how mainReconfigureFinish()
/// does it in a harsh reconfiguration case) OR every time one of the sufficient
/// conditions was detected by some directive-specific reconfiguration code.
///
/// For example, reconfiguration must rehash carp cache_peers (once) if an old
/// carp cache_peer has been removed or if its configuration has changed. Those
/// two conditions are detected in different parts of reconfiguration code,
/// necessitating some shared state. This class manages that state.
class SmoothReconfiguration
{
public:
    explicit SmoothReconfiguration(const PreprocessedCfg &);
    ~SmoothReconfiguration();

    /// performs all smooth reconfiguration steps
    void run();

    /// Requests to schedule an asynchronous call of the given function (at the
    /// last reconfiguration step). The call name is used to ignore repeated
    /// same-call requests.
    ///
    /// The calls are currently scheduled in implementation-defined order. Avoid
    /// duplicating same-call callers; we may add call order parameters!
    template <typename Dialer>
    inline void asyncCall(int debugSection, int debugLevel, const char *callName, const Dialer &);

    /// configuration we are tasked with interpreting and applying
    const PreprocessedCfg &freshConfig;

    CachePeers *oldPeers;

protected:
    /// Component-specific reconfiguration steps to run before we reconfigure()
    /// each directive. Defined in cf_parser.cci generated by cf_gen.cc.
    void prepComponents();

    /// Component-specific reconfiguration steps to run after we reconfigure()
    /// each directive. Defined in cf_parser.cci generated by cf_gen.cc.
    void finalizeComponents();

    /// Reconfiguration steps specific to the given configuration directive.
    /// Defined in cf_parser.cci generated by cf_gen.cc.
    void reconfigure(const PreprocessedDirective &);

    /// Schedules asynchronous calls requested by prior asyncCall() calls. This
    /// is the last explicit successful reconfiguration step. It happens after
    /// finalizeComponents().
    void finish();

private:
    /// calls we will schedule at the end of reconfiguration
    AsyncCallList plan_;
};

/// reconfigures preprocessed pliable directives
void PerformSmoothReconfiguration(const PreprocessedCfg &freshCfg);

} // namespace Configuration

template <typename Dialer>
void
Configuration::SmoothReconfiguration::asyncCall(const int debugSection, const int debugLevel, const char * const callName, const Dialer &dialer)
{
    // TODO: Optimize this. While the plan_ cannot contain more than a few dozen
    // entries (mainReconfigureFinish() has about 40 equivalent functions), this
    // search itself may eventually be performed _often_ (e.g., once for every
    // `acl` directive parsed??).
    if (!plan_.slowlyFindByName(callName))
        plan_.add(::asyncCall(debugSection, debugLevel, callName, dialer));
}

#endif /* SQUID_SRC_CONFIGURATION_SMOOTH_H */

