/*
 * Copyright (C) 1996-2024 The Squid Software Foundation and contributors
 *
 * Squid software is distributed under GPLv2+ license and includes
 * contributions from numerous individuals and organizations.
 * Please see the COPYING and CONTRIBUTORS files for details.
 */

#ifndef SQUID_SRC_CONFIGURATION_PREPROCESSOR_H
#define SQUID_SRC_CONFIGURATION_PREPROCESSOR_H

#include "configuration/forward.h"
#include "mem/PoolingAllocator.h"
#include "sbuf/Algorithms.h"
#include "sbuf/forward.h"

#include <deque>
#include <memory>
#include <unordered_map>

namespace Configuration {

/// input coordinates with line number precision
class Location
{
public:
    explicit Location(const SBuf &aName, const size_t aLineNo = 0): name_(aName), lineNo_(aLineNo) {}

    /// input source description (e.g., a file name or a shell command)
    const auto &name() const { return name_; }

    /// line offset within input source; the first input byte has line offset 1
    auto lineNo() const { return lineNo_; }

    /// change line within the same input source
    void jumpTo(const size_t aLineNo) { lineNo_ = aLineNo; }

    /// convenience wrapper implementing a jumpTo() the next line
    Location &operator ++() { ++lineNo_; return *this; }

    /// reports location using a compact format suitable for diagnostic messages
    void print(std::ostream &) const;

private:
    SBuf name_; ///< \copydoc name()
    size_t lineNo_; ///< \copydoc lineNo()
};

/// \copydoc Location::print()
inline
std::ostream&
operator <<(std::ostream &os, const Location &l)
{
    l.print(os);
    return os;
}

/// a single preprocessed configuration directive (with a recognized directive name)
class PreprocessedDirective
{
public:
    /// facts about a directive; collected from cf.data.pre during Squid build
    class Metadata {
    public:
        /// the first entry on directive's "NAME: canonicalName alias..." list
        SBuf canonicalName;

        /// whether this is a pliable directive (as defined by "reconfiguration" directive)
        bool supportsSmoothReconfiguration = false;

        /// whether this directive may be repeated in the configuration file
        bool mayBeSeenMultipleTimes = false;
    };

    PreprocessedDirective(const SBuf &aWhole, bool doesHonorQuotedParameters);

    /// entire preprocessed directive configuration, starting from the name and
    /// ending with the last parameter (if any)
    const auto &whole() const { return whole_; }

    /// the first token on a directive line; never empty
    const SBuf &name() const { return name_; }

    /// (unfolded) directive line contents after the name prefix; may be empty
    /// \sa honorsQuotedParameters()
    const SBuf &parameters() const { return parameters_; }

    /// where this directive was obtained from
    const Location &location() const { return location_; }

    /// facts collected from cf.data.pre entry for this directive
    const Metadata &metadata() const { return metadata_; }

    /// whether parameters() should be parsed in `configuration_includes_quoted_values on` context
    bool honorsQuotedParameters() const { return honorsQuotedParameters_; }

    void print(std::ostream &) const;

private:
    // defined in cf_parser.cci generated by cf_gen.cc
    static Metadata GetMetadata(const SBuf &name);

    SBuf whole_; ///< \copydoc whole()
    SBuf name_; ///< \copydoc name()
    SBuf parameters_; ///< \copydoc parameters()
    Location location_; ///< \copydoc location()
    Metadata metadata_; ///< \copydoc metadata()
    bool honorsQuotedParameters_; ///< \copydoc honorsQuotedParameters()
};

/// artifacts of successful preprocessing; Preprocess() result
class PreprocessedCfg: public RefCountable
{
public:
    using Pointer = RefCount<PreprocessedCfg>;

    using Directive = PreprocessedDirective;

    /// preprocessed configuration directives in configuration order
    using Directives = std::deque<Directive, PoolingAllocator<Directive> >;

    /// a reference to the directive stored in Directives
    using IndexedDirective = std::reference_wrapper<const Directive>;

    /// an order-preserving view of a subset of Directives
    using SelectedDirectives = std::deque<IndexedDirective, PoolingAllocator<IndexedDirective> >;

    /// DirectivesByName declaration helper
    using DirectivesByNameElement = std::pair<const SBuf, IndexedDirective>;
    /// a view of a subset of directives with fast lookup by name
    using DirectivesByName = std::unordered_map<SBuf, IndexedDirective, std::hash<SBuf>, std::equal_to<SBuf>, PoolingAllocator<DirectivesByNameElement> >;

    /// whether this configuration contains at least one named directive
    bool hasDirective(const SBuf &canonicalName) const;

public:
    /// pliable and rigid directive storage
    /// \sa pliableDirectives and rigidDirectives
    Directives allDirectives;

    /// Directives (including defaults) that support smooth reconfiguration.
    /// \sa rigidDirectives
    SelectedDirectives pliableDirectives;

    /// Directives (including defaults) that do not support smooth
    /// reconfiguration. A change in a rigid directive prevents smooth
    /// reconfiguration.
    /// \sa pliableDirectives
    SelectedDirectives rigidDirectives;

    /// directives seen so far; if a directive was seen multiple times, we store
    /// the last instance seen
    DirectivesByName seenDirectives_;

    /// whether all rigid directives were preserved compared to the previous
    /// version of Squid configuration in Preprocess() caller possession
    bool allowSmoothReconfiguration = false;

    /// whether reconfiguration directive allows harsh reconfiguration
    bool allowHarshReconfiguration = false;
};

// TODO: Move this class (and other "internally-used" code) to Preprocessor.cc!
/// Processes Squid configuration up to (and excluding) parsing of individual
/// directives (each described as a NAME:... blob in cf.data.pre). Handles
/// includes, conditional configuration, and ${macros}. Generates default
/// directives.
class Preprocessor
{
public:
    /* these public methods are orchestrated by Preprocess() */

    Preprocessor();

    /// import all directives, including various defaults and included files
    void process(const char * const filename);

    /// decide whether to banSmoothReconfiguration()
    void assessSmoothConfigurationTolerance(const PreprocessedCfg::Pointer &previousCfg);

    /// produce preprocessed configuration suitable for external consumption
    PreprocessedCfg::Pointer finalize();

private:
    void processFile(const char *filename, size_t depth);
    void processIncludedFiles(const SBuf &paths, size_t depth);
    void processIncludesQuotedValuesInstruction(const SBuf &);

    void importDefaultDirective(const SBuf &whole);
    void processDirective(const SBuf &rawWhole);
    void addDirective(const PreprocessedDirective &);
    bool sawDirective(const SBuf &canonicalName) const;

    void banSmoothReconfiguration(const char *reason);
    Diff findRigidChanges(const PreprocessedCfg::SelectedDirectives &previous) const;

    /* methods below are defined in cf_parser.cci generated by cf_gen.cc */
    void processInitialDefaults();
    void processIfNoneDefaults();
    void processPostscriptumDefaults();

private:
    /// preprocessed configuration being built by this object
    PreprocessedCfg::Pointer cfg_;

    /// The number of lines we could not preprocess so far. This counter
    /// includes, without limitation, directives with misspelled names and
    /// directives that are disabled in this particular Squid build.
    size_t invalidLines_ = 0;

    /// banSmoothReconfiguration() call reason (for debugging) or, if there was
    /// no such call, nil
    const char *smoothReconfigurationBan_ = nullptr;

    /// the last seen `configuration_includes_quoted_values` value
    bool honorsQuotedParameters_ = false;
};

/// Interprets Squid configuration up to (and excluding) parsing of individual
/// directives. Returns a sequence of directives to parse, including various
/// defaults. Does not affect current Squid configuration. Never returns nil.
PreprocessedCfg::Pointer Preprocess(const char *filename, const PreprocessedCfg::Pointer &previousCfg);

inline
std::ostream&
operator <<(std::ostream &os, const PreprocessedDirective &d)
{
    d.print(os);
    return os;
}

} // namespace Configuration

#endif /* SQUID_SRC_CONFIGURATION_PREPROCESSOR_H */

