/*
 * Copyright (C) 1996-2024 The Squid Software Foundation and contributors
 *
 * Squid software is distributed under GPLv2+ license and includes
 * contributions from numerous individuals and organizations.
 * Please see the COPYING and CONTRIBUTORS files for details.
 */

#ifndef SQUID_SRC_CONFIGURATION_PREPROCESSOR_H
#define SQUID_SRC_CONFIGURATION_PREPROCESSOR_H

#include "configuration/forward.h"
#include "sbuf/Algorithms.h"
#include "sbuf/forward.h"

#include <deque>
#include <memory>
#include <unordered_set>

namespace Configuration {

/// artifacts of successful preprocessing; Preprocess() result
class PreprocessedCfg: public RefCountable
{
public:
    using Pointer = RefCount<PreprocessedCfg>;

    using Directive = PreprocessedDirective;

    /// preprocessed configuration directives in configuration order
    using Directives = std::deque< /* const here XXX? */ Directive /* XXX: Pool */ >;

    /// all successfully preprocessed directives; TODO: rename to directives
    Directives allDirectives;
};

/// Processes Squid configuration up to (and excluding) parsing of individual
/// directives (each described as a NAME:... blob in cf.data.pre). Handles
/// includes, conditional configuration, and ${macros}. Generates default
/// directives.
class Preprocessor
{
public:
    Preprocessor();

    /// Provides configuration parser with a sequence of preprocessed
    /// directives, including various defaults.
    PreprocessedCfg::Pointer process(const char * const filename);

private:
    void processFile(const char *filename, size_t depth);
    void processIncludedFiles(const SBuf &paths, size_t depth);

    void importDefaultDirective(const char *);

    /* all methods below are defined in cf_parser.cci generated by cf_gen.cc */

    static bool ValidDirectiveName(const SBuf &);

    void processInitialDefaults();
    void processIfNoneDefaults();
    void processPostscriptumDefaults();

    void processUnfoldedLine(const SBuf &line);
    void addDirective(const SBuf &name, const SBuf &cfg);

    bool sawDirective(const char *name) const;

    void default_line(const char *s);

    /// preprocessed configuration being built by this object
    PreprocessedCfg::Pointer cfg_;

    /// a collection of directives names with fast lookup
    using SeenNames = std::unordered_set<SBuf /* Pool? */>;
    /// directives names seen so far
    SeenNames seenDirectives_;

    /// The number of lines we could not preprocess so far. This counter
    /// includes, without limitation, directives with misspelled names and
    /// directives that are disabled in this particular Squid build.
    size_t invalidLines_ = 0;
};

/// a single preprocessed configuration directive (supported or otherwise)
class PreprocessedDirective
{
public:
    PreprocessedDirective(const SBuf &aName, const SBuf &params): name_(aName), buf_(params) {}

    /// the first token on a directive line; never empty
    const SBuf &name() const { return name_; }

    /// (unfolded) directive line contents after the name prefix; may be empty
    const SBuf &parameters() const { return buf_; }

    /// whether the other directive is similar to this one
    bool similarTo(const PreprocessedDirective &other) const;

    void print(std::ostream &) const;

private:
    SBuf name_; ///< \copydoc name()
    SBuf buf_; ///< \copydoc contents(); XXX: rename to parameters_
};

/// Interprets Squid configuration up to (and excluding) parsing of individual
/// directives. Returns a sequence of directives to parse, including various
/// defaults. Does not affect current Squid configuration. Never returns nil.
PreprocessedCfg::Pointer Preprocess(const char *filename);

} // namespace Configuration

// XXX: Move into Configuration; see commit 25ecffe5
inline
std::ostream&
operator <<(std::ostream &os, const Configuration::PreprocessedDirective &d)
{
    d.print(os);
    return os;
}

#endif /* SQUID_SRC_CONFIGURATION_PREPROCESSOR_H */

