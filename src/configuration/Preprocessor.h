/*
 * Copyright (C) 1996-2024 The Squid Software Foundation and contributors
 *
 * Squid software is distributed under GPLv2+ license and includes
 * contributions from numerous individuals and organizations.
 * Please see the COPYING and CONTRIBUTORS files for details.
 */

#ifndef SQUID_SRC_CONFIGURATION_PREPROCESSOR_H
#define SQUID_SRC_CONFIGURATION_PREPROCESSOR_H

#include "configuration/forward.h"
#include "mem/PoolingAllocator.h"
#include "sbuf/Algorithms.h"
#include "sbuf/forward.h"

#include <deque>
#include <memory>
#include <unordered_map>

namespace Configuration {

/// input coordinates with line number precision
class Location
{
public:
    explicit Location(const SBuf &aName, const size_t aLineNo = 0): name_(aName), lineNo_(aLineNo) {}

    /// input source description (e.g., a file name or a shell command)
    const auto &name() const { return name_; }

    /// line offset within input source; the first input byte has line offset 1
    auto lineNo() const { return lineNo_; }

    /// change line within the same input source
    void jumpTo(const size_t aLineNo) { lineNo_ = aLineNo; }

    /// convenience wrapper implementing a jumpTo() the next line
    Location &operator ++() { ++lineNo_; return *this; }

    /// reports location using a compact format suitable for diagnostic messages
    void print(std::ostream &) const;

private:
    SBuf name_; ///< \copydoc name()
    size_t lineNo_; ///< \copydoc lineNo()
};

/// \copydoc Location::print()
inline
std::ostream&
operator <<(std::ostream &os, const Location &l)
{
    l.print(os);
    return os;
}

/// a single preprocessed configuration directive (with a recognized directive name)
class PreprocessedDirective
{
public:
    /// represents possible differences between two directives
    class Diff {
    public:
        /// difference type bitmasks
        enum class Scope: uint8_t {
            none =  0, ///< directives are identical in all respects
            look =  0x1, ///< all "visible" differences (e.g., parameter spelling or spacing)
            quoting =  0x2 ///< have different configuration_includes_quoted_values setting
        };

        explicit operator bool() { return scope_ != Scope::none; }
        void setLook();
        bool hasLook() const;
        void setQuoting();
        bool hasQuoting() const;

    private:
        Scope scope_ = Scope::none;
    };

    /// facts about a directive; collected from cf.data.pre during Squid build
    class Metadata {
    public:
        /// the first entry on directive's "NAME: canonicalName alias..." list
        SBuf canonicalName;

        /// whether this is a pliable directive (as defined by "reconfiguration" directive)
        bool supportsSmoothReconfiguration = false;

        /// whether this directive may be repeated in the configuration file
        bool mayBeSeenMultipleTimes = false;
    };

    explicit PreprocessedDirective(const SBuf &aWhole, bool isQuoted);

    /// entire preprocessed directive configuration, starting from the name and
    /// ending with the last parameter (if any)
    const auto &whole() const { return whole_; }

    /// the first token on a directive line; never empty
    const SBuf &name() const { return name_; }

    /// (unfolded) directive line contents after the name prefix; may be empty
    const SBuf &parameters() const { return parameters_; }

    /// where this directive was obtained from
    const Location &location() const { return location_; }

    /// facts collected from cf.data.pre entry for this directive
    const Metadata &metadata() const { return metadata_; }

    /// ConfigParser::RecognizeQuotedValues will be true during parsing this directive
    bool quoted() const { return quoted_; }

    /// whether the other directive is similar to this one
    Diff differsFrom(const PreprocessedDirective &other) const;

    void print(std::ostream &) const;

private:
    // defined in cf_parser.cci generated by cf_gen.cc
    static Metadata GetMetadata(const SBuf &name);

    SBuf whole_; ///< \copydoc whole()
    SBuf name_; ///< \copydoc name()
    SBuf parameters_; ///< \copydoc parameters()
    Location location_; ///< \copydoc location()
    Metadata metadata_; ///< \copydoc metadata()
    bool quoted_; ///< copydoc quoted()
};

inline auto
operator|(const PreprocessedDirective::Diff::Scope a,  const PreprocessedDirective::Diff::Scope b)
{
    using PD = PreprocessedDirective::Diff::Scope;
    return static_cast<PD>(std::underlying_type<PD>::type(a) | std::underlying_type<PD>::type(b));
}

inline auto
operator&(const PreprocessedDirective::Diff::Scope a,  const PreprocessedDirective::Diff::Scope b)
{
    using PD = PreprocessedDirective::Diff::Scope;
    return static_cast<PD>(std::underlying_type<PD>::type(a) & std::underlying_type<PD>::type(b));
}

inline auto &
operator|=(PreprocessedDirective::Diff::Scope &a, const PreprocessedDirective::Diff::Scope b)
{
    return a = a | b;
}

inline auto &
operator&=(PreprocessedDirective::Diff::Scope &a, const PreprocessedDirective::Diff::Scope b)
{
    return a = a & b;
}

/// artifacts of successful preprocessing; Preprocess() result
class PreprocessedCfg: public RefCountable
{
public:
    using Pointer = RefCount<PreprocessedCfg>;

    using Directive = PreprocessedDirective;

    /// preprocessed configuration directives in configuration order
    using Directives = std::deque<Directive, PoolingAllocator<Directive> >;

    /// a reference to the directive stored in Directives
    using IndexedDirective = std::reference_wrapper<const Directive>;

    /// an order-preserving view of a subset of Directives
    using SelectedDirectives = std::deque<IndexedDirective, PoolingAllocator<IndexedDirective> >;

    /// DirectivesByName declaration helper
    using DirectivesByNameElement = std::pair<const SBuf, IndexedDirective>;
    /// a view of a subset of directives with fast lookup by name
    using DirectivesByName = std::unordered_map<SBuf, IndexedDirective, std::hash<SBuf>, std::equal_to<SBuf>, PoolingAllocator<DirectivesByNameElement> >;

    /// whether this configuration contains at least one named directive
    bool hasDirective(const SBuf &canonicalName) const;

public:
    /// pliable and rigid directive storage
    /// \sa pliableDirectives and rigidDirectives
    Directives allDirectives;

    /// Directives (including defaults) that support smooth reconfiguration.
    /// \sa rigidDirectives
    SelectedDirectives pliableDirectives;

    /// Directives (including defaults) that do not support smooth
    /// reconfiguration. A change in a rigid directive prevents smooth
    /// reconfiguration.
    /// \sa pliableDirectives
    SelectedDirectives rigidDirectives;

    /// directives seen so far; if a directive was seen multiple times, we store
    /// the last instance seen
    DirectivesByName seenDirectives_;

    /// whether all rigid directives were preserved compared to the previous
    /// version of Squid configuration in Preprocess() caller possession
    bool allowSmoothReconfiguration = false;

    /// whether reconfiguration directive allows harsh reconfiguration
    bool allowHarshReconfiguration = false;
};

// TODO: Move this class (and other "internally-used" code) to Preprocessor.cc!
/// Processes Squid configuration up to (and excluding) parsing of individual
/// directives (each described as a NAME:... blob in cf.data.pre). Handles
/// includes, conditional configuration, and ${macros}. Generates default
/// directives.
class Preprocessor
{
public:
    /* these public methods are orchestrated by Preprocess() */

    Preprocessor();

    /// import all directives, including various defaults and included files
    void process(const char * const filename);

    /// decide whether to banSmoothReconfiguration()
    void assessSmoothConfigurationTolerance(const PreprocessedCfg::Pointer &previousCfg);

    /// produce preprocessed configuration suitable for external consumption
    PreprocessedCfg::Pointer finalize();

private:
    void processFile(const char *filename, size_t depth);
    void processIncludedFiles(const SBuf &paths, size_t depth);
    void processIncludesQuotedValues(SBuf);

    void importDefaultDirective(const SBuf &whole);
    void processDirective(const SBuf &rawWhole);
    void addDirective(const PreprocessedDirective &);
    bool sawDirective(const SBuf &canonicalName) const;

    void banSmoothReconfiguration(const char *reason);
    Diff findRigidChanges(const PreprocessedCfg::SelectedDirectives &previous) const;

    /* methods below are defined in cf_parser.cci generated by cf_gen.cc */
    void processInitialDefaults();
    void processIfNoneDefaults();
    void processPostscriptumDefaults();

private:
    /// preprocessed configuration being built by this object
    PreprocessedCfg::Pointer cfg_;

    /// The number of lines we could not preprocess so far. This counter
    /// includes, without limitation, directives with misspelled names and
    /// directives that are disabled in this particular Squid build.
    size_t invalidLines_ = 0;

    /// banSmoothReconfiguration() call reason (for debugging) or, if there was
    /// no such call, nil
    const char *smoothReconfigurationBan_ = nullptr;

    /// the `configuration_includes_quoted_values` preprocessor directive value
    /// that has been preprocessed last
    bool includesQuotedValues_ = false;
};

/// Interprets Squid configuration up to (and excluding) parsing of individual
/// directives. Returns a sequence of directives to parse, including various
/// defaults. Does not affect current Squid configuration. Never returns nil.
PreprocessedCfg::Pointer Preprocess(const char *filename, const PreprocessedCfg::Pointer &previousCfg);

inline
std::ostream&
operator <<(std::ostream &os, const PreprocessedDirective &d)
{
    d.print(os);
    return os;
}

} // namespace Configuration

#endif /* SQUID_SRC_CONFIGURATION_PREPROCESSOR_H */

